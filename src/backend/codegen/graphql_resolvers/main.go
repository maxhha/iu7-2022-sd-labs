package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

var baseTemplate = template.Must(template.New("baseTemplate").Parse(`
// This file was generated by codegen/graphql_resolvers. DO NOT EDIT.
package resolvers

import (
	"context"
	"iu7-2022-sd-labs/buisness/ports/repositories"
	"iu7-2022-sd-labs/server/models"
{{
	range $import, $i := .Imports 
}}	"{{ $import }}"
{{ end 
}})

`))

var resolverToTemplate = map[string]*template.Template{
	"QueryPagination": template.Must(template.New("queryPaginaerionTemplate").Parse(`
func (r *queryResolver) generatedPagination__{{ .Entity }}s(ctx context.Context, first *int, after *string, filter *models.{{ .Entity }}Filter) (*models.{{ .Entity }}Connection, error) {
	ents, err := r.{{ .LocalEntity }}Interactor.Find(&repositories.{{ .Entity }}FindParams{
		Filter: filter.Into(&repositories.{{ .Entity }}Filter{}),
		Order: &repositories.{{ .Entity }}Order{
			By:   repositories.{{ .Entity }}OrderFieldCreationDate,
			Desc: true,
		},
		Slice: models.FillForwardSlice(first, after, &repositories.ForwardSlice{}),
	})
	if err != nil {
		return nil, Wrap(err, "{{ .LocalEntity }} interactor find")
	}

	if len(ents) == 0 {
		return &models.{{ .Entity }}Connection{PageInfo: &models.PageInfo{}}, nil
	}

	objs := models.{{ .Entity }}EdgesArrayFromEntites(ents)

	hasNextPage := false
	if first != nil {
		hasNextPage = len(objs) > *first
		objs = objs[:len(objs)-1]
	}

	return &models.{{ .Entity }}Connection{
		PageInfo: &models.PageInfo{
			HasNextPage: hasNextPage,
			StartCursor: &objs[0].Cursor,
			EndCursor:   &objs[len(objs)-1].Cursor,
		},
		Edges: objs,
	}, nil
}
`)),
}

var resolverToImports = map[string][]string{
	"QueryPagination": {},
}

type Config struct {
	Entity      string
	LocalEntity string
	Resolvers   []string
	Imports     map[string]struct{}
}

func (config *Config) Generate(out io.Writer) {
	if err := baseTemplate.Execute(out, config); err != nil {
		log.Fatalf("baseTemplate.Execute: %v", err)
	}

	for _, r := range config.Resolvers {
		templ, exists := resolverToTemplate[r]
		if !exists {
			log.Fatalf("unknown resolver \"%s\"", r)
		}

		if err := templ.Execute(out, config); err != nil {
			log.Fatalf("operationToTemplate[%s].Execute: %v", r, err)
		}
	}
}

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

func main() {
	fileout := flag.String("out", "", "output file")
	entity := flag.String("entity", "", "enitity name")
	resolvers := flag.String("resolvers", "", "resolvers list")
	flag.Parse()

	out, err := os.Create(*fileout)
	if err != nil {
		log.Fatalf("create file: %v", err)
	}

	resolversList := strings.Split(*resolvers, ",")

	imports := make(map[string]struct{})
	for _, m := range resolversList {
		imps, exists := resolverToImports[m]
		if !exists {
			continue
		}
		for _, i := range imps {
			imports[i] = struct{}{}
		}
	}

	config := Config{
		Entity:      *entity,
		LocalEntity: lowerFirst(*entity),
		Resolvers:   resolversList,
		Imports:     imports,
	}

	var buf bytes.Buffer
	config.Generate(&buf)

	p, err := format.Source(buf.Bytes())

	if err != nil {
		log.Fatalf("format error: %v", err)
	}
	out.Write(p)
	out.Close()
	fmt.Printf("%s[%s] -> %s\n", *entity, *resolvers, *fileout)
}
