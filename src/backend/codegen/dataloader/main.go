package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

var baseTemplate = template.Must(template.New("baseTemplate").Parse(`
// This file was generated by codegen/dataloader. DO NOT EDIT.
package dataloader

import (
	"context"
	"fmt"
	"iu7-2022-sd-labs/buisness/entities"
	"iu7-2022-sd-labs/buisness/ports/repositories"

	"github.com/graph-gophers/dataloader"
)

type contextKey struct {
	name string
}

var loaderKey = contextKey{name: "loader"}

type DataLoader struct {
	repo repositories.Repository
}

type loaders struct {
	{{ range .Entities }}
	{{ .Low }} *dataloader.Loader{{ end }}
}

func NewDataLoader(repo repositories.Repository) *DataLoader {
	return &DataLoader{
		repo: repo,
	}
}

{{ range .Entities }}
func (l *DataLoader) {{ .Low }}BatchFn(ctx context.Context, keys dataloader.Keys) []*dataloader.Result {
	results := make([]*dataloader.Result, 0, len(keys))
	ids := make([]string, 0, len(keys))
	for _, key := range keys {
		ids = append(ids, key.String())
	}

	ents, err := l.repo.{{ .Cap }}().Find(&repositories.{{ .Cap }}FindParams{
		Filter: &repositories.{{ .Cap }}Filter{IDs: ids},
	})

	if err != nil {
		result := dataloader.Result{
			Error: err,
		}

		for i := 0; i < len(keys); i++ {
			results = append(results, &result)
		}

		return results
	}

	entsMap := make(map[string]interface{}, len(ents))
	for _, ent := range ents {
		entsMap[ent.ID()] = ent
	}

	for _, id := range ids {
		result := dataloader.Result{}
		ent, ok := entsMap[id]
		if ok {
			result.Data = ent
		} else {
			result.Error = repositories.ErrNotFound
		}
		results = append(results, &result)
	}

	return results
}
{{ end }}

func (f *DataLoader) WithNewLoader(ctx context.Context) context.Context {
	return context.WithValue(ctx, loaderKey, loaders{
		{{ range .Entities }}
		dataloader.NewBatchedLoader(f.{{ .Low }}BatchFn),{{ end }}
	})
}

{{ range .Entities }}
func (l *DataLoader) Load{{ .Cap }}(ctx context.Context, id string) (entities.{{ .Cap }}, error) {
	loaders, ok := ctx.Value(loaderKey).(loaders)
	if !ok {
		return entities.{{ .Cap }}{}, fmt.Errorf("fail get loader from context")
	}

	thunk := loaders.{{ .Low }}.Load(ctx, dataloader.StringKey(id))
	obj, err := thunk()
	if err != nil {
		return entities.{{ .Cap }}{}, fmt.Errorf("{{ .Low }} loader thunk: %w", err)
	}

	ent, ok := obj.(entities.{{ .Cap }})
	if !ok {
		return entities.{{ .Cap }}{}, fmt.Errorf(
			"fail convert thunk result of type %T to {{ .Cap }}",
			obj,
		)
	}

	return ent, nil
}
{{ end }}
`))

type Entity struct {
	Cap string
	Low string
}

type Config struct {
	Entities []Entity
}

func (config *Config) Generate(out io.Writer) {
	if err := baseTemplate.Execute(out, config); err != nil {
		log.Fatalf("baseTemplate.Execute: %v", err)
	}
}

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

func main() {
	fileout := flag.String("out", "", "output file")
	entities := flag.String("entities", "", "enitities list")
	flag.Parse()

	out, err := os.Create(*fileout)
	if err != nil {
		log.Fatalf("create file: %v", err)
	}

	entitiesNamesList := strings.Split(*entities, ",")
	entitiesList := make([]Entity, 0, len(entitiesNamesList))
	for _, name := range entitiesNamesList {
		entitiesList = append(entitiesList, Entity{
			Cap: name,
			Low: lowerFirst(name),
		})
	}

	config := Config{
		Entities: entitiesList,
	}

	var buf bytes.Buffer
	config.Generate(&buf)

	p, err := format.Source(buf.Bytes())

	if err != nil {
		log.Fatalf("format error: %v", err)
	}
	out.Write(p)
	out.Close()
	fmt.Printf("dataloader generated for %s\n", *entities)
}
