package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

var baseTemplate = template.Must(template.New("baseTemplate").Parse(`
// This file was generated by codegen/gorm_repository. DO NOT EDIT.
package gorm_repositories

import (
	"iu7-2022-sd-labs/buisness/ports/repositories"

	"gorm.io/gorm"
{{
	range $import, $i := .Imports 
}}	"{{ $import }}"
{{ end 
}})

type {{ .Entity }}Repository struct { db *gorm.DB }

func (r *GORMRepository) {{ .Entity }}() repositories.{{ .Entity }}Repository {
	return &{{ .Entity }}Repository{r.db}
}
`))

var methodToTemplate = map[string]*template.Template{
	"Get": template.Must(template.New("getTemplate").Parse(`
func (r *{{ .Entity }}Repository) Get(id string) (entities.{{ .Entity }}, error) {
	obj := {{ .Entity }}{}
	ent := entities.New{{ .Entity }}()

	if err := r.db.Take(&obj, "id = ?", id).Error; err != nil {
		return ent, Wrap(err, "db take")
	}

	obj.Into(&ent)
	return ent, nil
}
`)),
	"Lock": template.Must(template.New("lockTemplate").Parse(`
func (r *{{ .Entity }}Repository) Lock(id string) (entities.{{ .Entity }}, error) {
	obj := {{ .Entity }}{}
	ent := entities.New{{ .Entity }}()

	err := r.db.Clauses(clause.Locking{
		Strength: "UPDATE",
		Table:    clause.Table{Name: clause.CurrentTable},
	}).
		Take(&obj, "id = ?", id).
		Error
	if err != nil {
		return ent, Wrap(err, "db select for update")
	}

	obj.Into(&ent)
	return ent, nil
}
`)),
	"ShareLock": template.Must(template.New("lockTemplate").Parse(`
func (r *{{ .Entity }}Repository) ShareLock(id string) (entities.{{ .Entity }}, error) {
	obj := {{ .Entity }}{}
	ent := entities.New{{ .Entity }}()

	err := r.db.Clauses(clause.Locking{
		Strength: "SHARE",
		Table:    clause.Table{Name: clause.CurrentTable},
	}).
		Take(&obj, "id = ?", id).
		Error
	if err != nil {
		return ent, Wrap(err, "db select for update")
	}

	obj.Into(&ent)
	return ent, nil
}
`)),
	"Find": template.Must(template.New("findTemplate").Parse(`
func (r *{{ .Entity }}Repository) Find(params *repositories.{{ .Entity }}FindParams) ([]entities.{{ .Entity }}, error) {
	query := r.db.Model(&{{ .Entity }}{})

	if params != nil {
		var err error
		if query, err = r.filterQuery(query, params.Filter); err != nil {
			return nil, Wrap(err, "filter query")
		}

		if query, err = r.orderQuery(query, params.Order); err != nil {
			return nil, Wrap(err, "order query")
		}

		if query, err = r.sliceQuery(query, params.Order, params.Slice); err != nil {
			return nil, Wrap(err, "slice query")
		}
	}

	var objs []{{ .Entity }}
	if err := query.Find(&objs).Error; err != nil {
		return nil, Wrap(err, "db find")
	}

	ents := make([]entities.{{ .Entity }}, 0, len(objs))

	for _, obj := range objs {
		ent := entities.New{{ .Entity }}()
		obj.Into(&ent)
		ents = append(ents, ent)
	}

	return ents, nil
}
`)),
	"Create": template.Must(template.New("createTemplate").Parse(`
func (r *{{ .Entity }}Repository) Create(ent *entities.{{ .Entity }}) error {
	obj := {{ .Entity }}{}
	obj.From(ent)

	if err := r.db.Create(&obj).Error; err != nil {
		return Wrap(err, "db create")
	}

	obj.Into(ent)
	return nil
}
`)),
	"Delete": template.Must(template.New("deleteTemplate").Parse(`
func (r *{{ .Entity }}Repository) Delete(id string) (entities.{{ .Entity }}, error) {
	obj := {{ .Entity }}{}
	ent := entities.New{{ .Entity }}()

	err := r.db.Transaction(func(tx *gorm.DB) error {
		err := r.db.Clauses(clause.Locking{
			Strength: "UPDATE",
			Table:    clause.Table{Name: clause.CurrentTable},
		}).
			Take(&obj, "id = ?", id).
			Error

		if err != nil {
			return Wrap(err, "db select for update")
		}

		if err := r.db.Delete(&obj).Error; err != nil {
			return Wrap(err, "db delete")
		}

		return nil
	})

	if err != nil {
		return ent, Wrap(err, "db transaction")
	}

	obj.Into(&ent)
	return ent, nil
}	
`)),
	"orderQuery": template.Must(template.New("orderQueryTemplate").Parse(`
func (r *{{ .Entity }}Repository) orderQuery(query *gorm.DB, order *repositories.{{ .Entity }}Order) (*gorm.DB, error) {
	if order == nil {
		return query, nil
	}

	column, exists := {{ .LocalEntity }}FieldToColumn[order.By]
	if !exists {
		return nil, fmt.Errorf("column for field \"%s\" is unknown", order.By)
	}

	query = query.Order(clause.OrderByColumn{
		Column: clause.Column{Name: column},
		Desc:   order.Desc,
	})

	return query, nil
}
`)),
	"sliceQuery": template.Must(template.New("sliceQueryTemplate").Parse(`
func (r *{{ .Entity }}Repository) sliceQuery(query *gorm.DB, order *repositories.{{ .Entity }}Order, slice *repositories.ForwardSlice) (*gorm.DB, error) {
	if slice == nil {
		return query, nil
	}

	column, exists := {{ .LocalEntity }}FieldToColumn[order.By]
	if !exists {
		return nil, fmt.Errorf("column for field \"%s\" is unknown", order.By)
	}

	var err error
	query, err = sliceQuery(query, column, order.Desc, slice)
	return query, Wrap(err, "sliceQuery")
}
`)),
	"Update(updateFn)": template.Must(template.New("updateCallbackTemplate").Parse(`
func (r *{{ .Entity }}Repository) Update(id string, updateFn func(ent *entities.{{ .Entity }}) error) (entities.{{ .Entity }}, error) {
	obj := {{ .Entity }}{}
	ent := entities.New{{ .Entity }}()

	err := r.db.Transaction(func(tx *gorm.DB) error {
		err := tx.Clauses(clause.Locking{
			Strength: "UPDATE",
			Table:    clause.Table{Name: clause.CurrentTable},
		}).
			Take(&obj, "id = ?", id).
			Error

		if err != nil {
			return Wrap(err, "db select lock for update")
		}

		if err = updateFn(obj.Into(&ent)); err != nil {
			return Wrap(err, "updateFn")
		}

		obj.From(&ent)

		err = tx.Save(obj).Error
		return Wrap(err, "db save")
	})

	if err != nil {
		return ent, Wrap(err, "db transaction")
	}

	obj.Into(&ent)
	return ent, nil
}
`)),
	"Update": template.Must(template.New("updateTemplate").Parse(`
func (r *{{ .Entity }}Repository) Update(ent *entities.{{ .Entity }}) error {
	obj := {{ .Entity }}{}
	obj.From(ent)

	if err := r.db.Save(&obj).Error; err != nil {
		return Wrap(err, "db save")
	}

	obj.Into(ent)
	return nil
}
`)),
}

var methodToImports = map[string][]string{
	"Get":              {"iu7-2022-sd-labs/buisness/entities"},
	"Lock":             {"iu7-2022-sd-labs/buisness/entities", "gorm.io/gorm/clause"},
	"ShareLock":        {"iu7-2022-sd-labs/buisness/entities", "gorm.io/gorm/clause"},
	"Find":             {"iu7-2022-sd-labs/buisness/entities"},
	"Create":           {"iu7-2022-sd-labs/buisness/entities"},
	"Update(updateFn)": {"iu7-2022-sd-labs/buisness/entities", "gorm.io/gorm/clause"},
	"Update":           {"iu7-2022-sd-labs/buisness/entities"},
	"Delete":           {"iu7-2022-sd-labs/buisness/entities", "gorm.io/gorm/clause"},
	"orderQuery":       {"fmt", "gorm.io/gorm/clause"},
	"sliceQuery":       {"fmt", "gorm.io/gorm/clause"},
}

type Config struct {
	Entity      string
	LocalEntity string
	Methods     []string
	Imports     map[string]struct{}
}

func (config *Config) Generate(out io.Writer) {
	if err := baseTemplate.Execute(out, config); err != nil {
		log.Fatalf("baseTemplate.Execute: %v", err)
	}

	for _, m := range config.Methods {
		templ, exists := methodToTemplate[m]
		if !exists {
			log.Fatalf("unknown method \"%s\"", m)
		}

		if err := templ.Execute(out, config); err != nil {
			log.Fatalf("operationToTemplate[%s].Execute: %v", m, err)
		}
	}
}

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

func main() {
	fileout := flag.String("out", "", "output file")
	entity := flag.String("entity", "", "enitity name")
	methods := flag.String("methods", "", "methods list")
	flag.Parse()

	out, err := os.Create(*fileout)
	if err != nil {
		log.Fatalf("create file: %v", err)
	}

	methodsList := strings.Split(*methods, ",")

	imports := make(map[string]struct{})
	for _, m := range methodsList {
		imps, exists := methodToImports[m]
		if !exists {
			continue
		}
		for _, i := range imps {
			imports[i] = struct{}{}
		}
	}

	config := Config{
		Entity:      *entity,
		LocalEntity: lowerFirst(*entity),
		Methods:     methodsList,
		Imports:     imports,
	}

	var buf bytes.Buffer
	config.Generate(&buf)

	p, err := format.Source(buf.Bytes())

	if err != nil {
		log.Fatalf("format error: %v", err)
	}
	out.Write(p)
	out.Close()
	fmt.Printf("%s[%s] -> %s\n", *entity, *methods, *fileout)
}
