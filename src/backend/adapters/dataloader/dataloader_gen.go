// This file was generated by codegen/dataloader. DO NOT EDIT.
package dataloader

import (
	"context"
	"fmt"
	"iu7-2022-sd-labs/buisness/entities"
	"iu7-2022-sd-labs/buisness/ports/repositories"

	"github.com/graph-gophers/dataloader"
)

type contextKey struct {
	name string
}

var loaderKey = contextKey{name: "loader"}

type DataLoader struct {
	repo repositories.Repository
}

type loaders struct {
	organizer *dataloader.Loader
	room      *dataloader.Loader
	consumer  *dataloader.Loader
}

func NewDataLoader(repo repositories.Repository) *DataLoader {
	return &DataLoader{
		repo: repo,
	}
}

func (l *DataLoader) organizerBatchFn(ctx context.Context, keys dataloader.Keys) []*dataloader.Result {
	results := make([]*dataloader.Result, 0, len(keys))
	ids := make([]string, 0, len(keys))
	for _, key := range keys {
		ids = append(ids, key.String())
	}

	ents, err := l.repo.Organizer().Find(&repositories.OrganizerFindParams{
		Filter: &repositories.OrganizerFilter{IDs: ids},
	})

	if err != nil {
		result := dataloader.Result{
			Error: err,
		}

		for i := 0; i < len(keys); i++ {
			results = append(results, &result)
		}

		return results
	}

	entsMap := make(map[string]interface{}, len(ents))
	for _, ent := range ents {
		entsMap[ent.ID()] = ent
	}

	for _, id := range ids {
		result := dataloader.Result{}
		ent, ok := entsMap[id]
		if ok {
			result.Data = ent
		} else {
			result.Error = repositories.ErrNotFound
		}
		results = append(results, &result)
	}

	return results
}

func (l *DataLoader) roomBatchFn(ctx context.Context, keys dataloader.Keys) []*dataloader.Result {
	results := make([]*dataloader.Result, 0, len(keys))
	ids := make([]string, 0, len(keys))
	for _, key := range keys {
		ids = append(ids, key.String())
	}

	ents, err := l.repo.Room().Find(&repositories.RoomFindParams{
		Filter: &repositories.RoomFilter{IDs: ids},
	})

	if err != nil {
		result := dataloader.Result{
			Error: err,
		}

		for i := 0; i < len(keys); i++ {
			results = append(results, &result)
		}

		return results
	}

	entsMap := make(map[string]interface{}, len(ents))
	for _, ent := range ents {
		entsMap[ent.ID()] = ent
	}

	for _, id := range ids {
		result := dataloader.Result{}
		ent, ok := entsMap[id]
		if ok {
			result.Data = ent
		} else {
			result.Error = repositories.ErrNotFound
		}
		results = append(results, &result)
	}

	return results
}

func (l *DataLoader) consumerBatchFn(ctx context.Context, keys dataloader.Keys) []*dataloader.Result {
	results := make([]*dataloader.Result, 0, len(keys))
	ids := make([]string, 0, len(keys))
	for _, key := range keys {
		ids = append(ids, key.String())
	}

	ents, err := l.repo.Consumer().Find(&repositories.ConsumerFindParams{
		Filter: &repositories.ConsumerFilter{IDs: ids},
	})

	if err != nil {
		result := dataloader.Result{
			Error: err,
		}

		for i := 0; i < len(keys); i++ {
			results = append(results, &result)
		}

		return results
	}

	entsMap := make(map[string]interface{}, len(ents))
	for _, ent := range ents {
		entsMap[ent.ID()] = ent
	}

	for _, id := range ids {
		result := dataloader.Result{}
		ent, ok := entsMap[id]
		if ok {
			result.Data = ent
		} else {
			result.Error = repositories.ErrNotFound
		}
		results = append(results, &result)
	}

	return results
}

func (f *DataLoader) WithNewLoader(ctx context.Context) context.Context {
	return context.WithValue(ctx, loaderKey, loaders{

		dataloader.NewBatchedLoader(f.organizerBatchFn),
		dataloader.NewBatchedLoader(f.roomBatchFn),
		dataloader.NewBatchedLoader(f.consumerBatchFn),
	})
}

func (l *DataLoader) LoadOrganizer(ctx context.Context, id string) (entities.Organizer, error) {
	loaders, ok := ctx.Value(loaderKey).(loaders)
	if !ok {
		return entities.Organizer{}, fmt.Errorf("fail get loader from context")
	}

	thunk := loaders.organizer.Load(ctx, dataloader.StringKey(id))
	obj, err := thunk()
	if err != nil {
		return entities.Organizer{}, fmt.Errorf("organizer loader thunk: %w", err)
	}

	ent, ok := obj.(entities.Organizer)
	if !ok {
		return entities.Organizer{}, fmt.Errorf(
			"fail convert thunk result of type %T to Organizer",
			obj,
		)
	}

	return ent, nil
}

func (l *DataLoader) LoadRoom(ctx context.Context, id string) (entities.Room, error) {
	loaders, ok := ctx.Value(loaderKey).(loaders)
	if !ok {
		return entities.Room{}, fmt.Errorf("fail get loader from context")
	}

	thunk := loaders.room.Load(ctx, dataloader.StringKey(id))
	obj, err := thunk()
	if err != nil {
		return entities.Room{}, fmt.Errorf("room loader thunk: %w", err)
	}

	ent, ok := obj.(entities.Room)
	if !ok {
		return entities.Room{}, fmt.Errorf(
			"fail convert thunk result of type %T to Room",
			obj,
		)
	}

	return ent, nil
}

func (l *DataLoader) LoadConsumer(ctx context.Context, id string) (entities.Consumer, error) {
	loaders, ok := ctx.Value(loaderKey).(loaders)
	if !ok {
		return entities.Consumer{}, fmt.Errorf("fail get loader from context")
	}

	thunk := loaders.consumer.Load(ctx, dataloader.StringKey(id))
	obj, err := thunk()
	if err != nil {
		return entities.Consumer{}, fmt.Errorf("consumer loader thunk: %w", err)
	}

	ent, ok := obj.(entities.Consumer)
	if !ok {
		return entities.Consumer{}, fmt.Errorf(
			"fail convert thunk result of type %T to Consumer",
			obj,
		)
	}

	return ent, nil
}
